# Kafka 기본 구조

### [Kafka 공식 문서](https://kafka.apache.org/)

<br><br>

### Kafka란 : 분산 이벤트 스트리밍 플랫폼

<img src="../image/kafka-1/kafka-1-1.png" width="700">

<br>

Apache Kafka는 고성능 데이터 파이프라인, 스트리밍 분석, 데이터 통합, 그리고 핵심 비즈니스 애플리케이션에 사용되는 오픈 소스 분산 이벤트 스트리밍 플랫폼이다.

<br>

### 🤔 Tip

* **스트리밍 분석 (streaming analytics)** <br><br>
  * 실시간 또는 거의 실시간으로 들어오는 데이터 스트림을 연속적으로 분석하는 것을 의미.

<br>

* **데이터 파이프라인 (Data Pipeline)** <br><br>

  * **로그 수집**: 웹사이트나 애플리케이션의 사용자 활동 로그를 수집하여 중앙 데이터 저장소나 분석 플랫폼으로 전송하는 것. <br><br>

  * **E-commerce 트랜잭션 처리**: 온라인 상점에서 주문, 결제, 배송 정보 등의 트랜잭션 데이터를 처리하고, 이를 데이터베이스, 재고 관리 시스템, CRM 등과 연동하는 파이프라인 구축. <br><br>

  * **실시간 분석**: 소셜 미디어에서 실시간으로 생성되는 데이터를 수집, 처리, 분석하여 실시간 대시보드에 반영하는 파이프라인. <br><br>

<br>

* **데이터 통합 (Data Integration)** <br><br>

  * **여러 데이터베이스 통합**: 다양한 데이터베이스나 데이터 웨어하우스에서 데이터를 가져와 통합 저장소에 통합 저장.

<br><br><br>

<img src="../image/kafka-1/kafka-1-2.png" width="700">

<br><br>

### Kafka Cluster

* 여러 개의 브로커로 구성된 Kafka의 집합을 의미.


* 클러스터를 통해 데이터의 분산 저장 및 처리.

<br>

### Broker

* Kafka 시스템의 기본 서버 단위.


* 브로커는 클라이언트로부터 메시지를 받아 저장하고, 클라이언트가 요청할 때 메시지를 전달.


* 카프카 클러스터는 여러 브로커로 구성될 수 있다.

<br>

### Producer

* 데이터 또는 메시지를 생성하고 카프카 브로커에 전달하는 역할을 하는 클라이언트 애플리케이션. 


* 예를 들면, 로그 데이터를 생성하는 서버 등이 프로듀서의 역할을 할 수 있다.

<br>

### Consumer

* 카프카 브로커에서 메시지를 가져와 처리하는 클라이언트 애플리케이션. 


* 컨슈머는 특정 토픽의 데이터를 구독하며, 새로운 메시지가 들어오면 이를 가져와서 처리.

<br>

### ZooKeeper Ensemble

* Apache ZooKeeper는 분산 시스템의 설정 정보, 네이밍 등을 관리하기 위한 서비스. 


* 카프카는 메타데이터와 브로커의 상태, 리더 선출 등의 중요한 작업을 위해 ZooKeeper와 연동되어 동작한다. 


* 여러 개의 주키퍼 인스턴스로 구성된 것을 앙상블이라고 하며, 고가용성을 위해 주로 홀수 개의 인스턴스로 구성된다.

<br><br><br>

<img src="../image/kafka-1/kafka-1-3.png" width="700">

<br><br><br>

<img src="../image/kafka-1/kafka-1-4.png" width="700">

<br><br><br>

<img src="../image/kafka-1/kafka-1-5.png" width="700">

<br>

### 1. 라운드 로빈 방식

프로듀서는 순차적으로 각 파티션에 메시지를 저장한다. <br>
특정 파티션을 선호하지 않고, 균등하게 메시지를 분산하고 싶을 때 사용한다.

<br>

### 2. 키 기반 파티션 방식

각 메시지는 키와 함께 제공될 수 있다. 프로듀서는 이 키를 사용하여 메시지를 특정 파티션에 저장한다. <br>
같은 키를 가진 메시지는 항상 같은 파티션에 저장된다. 이 방식은 특정 키에 대한 메시지의 순서를 보장하고 싶을 때 사용된다.

<br> 

**Round Robin** : 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위로 CPU를 할당하는 방식.

<br><br><br>

<img src="../image/kafka-1/kafka-1-6.png" width="700">

<br>

### 중요 포인트

* 한 파티션의 메시지는 하나의 컨슈머에 의해 순차적으로 소비됩니다. 따라서 파티션 내의 메시지 순서는 보장된다.


* 컨슈머 그룹에 속한 컨슈머들은 하나의 파티션을 공유할 수 없다.

<br><br><br>

<img src="../image/kafka-1/kafka-1-7.png" width="700">

<br>

### OS 페이지 캐시 사용

Kafka는 로컬 저장소에 데이터를 저장할 때 파일 시스템을 사용한다. 이때, 대부분의 운영 체제는 OS 페이지 캐시라는 메모리 캐시를 사용하여 자주 액세스되는 파일의 데이터를 RAM에 캐싱한다.

이 캐시를 사용하면, 카프카는 디스크에서 직접 데이터를 읽는 대신 메모리에서 빠르게 데이터를 읽을 수 있다. 이로 인해 성능이 크게 향상된다.

그러나 이 페이지 캐시가 효율적으로 작동하려면 충분한 메모리 공간이 필요하다. 따라서 Kafka 서버는 다른 서비스와 메모리를 경쟁하지 않아야 한다.

<br>

### Zero Copy

Zero Copy는 데이터 전송 시 중간 버퍼에 데이터를 복사하지 않고 바로 전송하는 방식을 말한다.

이 기술을 사용하면 Kafka 브로커는 디스크에서 데이터를 읽어 네트워크로 바로 전송할 수 있다. 중간에 메모리로의 추가 복사 과정이 생략되므로 성능 향상과 CPU 사용률 절감을 기대할 수 있다.

<br>

### 컨슈머 추적 및 브로커의 단순성

Kafka 브로커는 메시지를 저장하고 전송하는 역할을 한다. 복잡한 메시지 필터링이나 재전송 기능을 내장하고 있지 않다.

컨슈머의 위치(오프셋) 추적은 브로커가 하지만, 실패한 메시지의 재처리나 메시지 필터링은 컨슈머나 프로듀서 애플리케이션에서 처리해야 한다.

이로 인해 Kafka 브로커는 높은 처리량과 낮은 지연 시간을 가질 수 있다.

간단히 말해, Kafka의 설계 원칙은 높은 처리량과 확장성을 중요시하며, 이를 위해 OS 페이지 캐시, Zero Copy, 그리고 브로커의 기능 단순화를 활용하고 있다.

<br><br><br>

<img src="../image/kafka-1/kafka-1-8.png" width="700">

<br>

### 프로듀서의 배치 처리

Kafka 프로듀서는 여러 메시지를 하나의 배치로 묶어서 브로커에게 전송할 수 있다.

이 방식은 네트워크 사용을 최적화하며 전체적인 처리량을 향상시킬 수 있다. 일정 시간동안 혹은 일정 크기의 메시지가 모이면 해당 메시지들을 한번에 전송한다.

Kafka 프로듀서 설정에서 batch.size와 linger.ms 옵션을 조정하여 메시지를 얼마나 오랫동안 모을 것인지, 또는 배치의 최대 크기는 얼마로 할 것인지를 설정할 수 있다.

<br>

### 컨슈머의 배치 처리

Kafka 컨슈머는 한 번의 요청으로 여러 메시지를 한꺼번에 가져올 수 있다.

fetch.min.bytes 설정을 통해 컨슈머가 데이터를 가져오기 위해 요청할 때 최소한으로 가져올 데이터의 크기를 지정할 수 있다. 이렇게 하면 네트워크 호출의 횟수를 줄이고, 대량의 데이터를 효율적으로 처리할 수 있다.

<br>

### 낱개 처리보다 처리량 증가

메시지를 개별적으로 보내거나 받는 것은 매번 네트워크 호출을 발생시킨다. 

반면에 배치 처리를 사용하면 여러 메시지를 한 번의 네트워크 호출로 전송하거나 수신할 수 있어서 오버헤드를 크게 줄일 수 있다. 또한, 디스크 I/O 작업을 최적화할 수 있기 때문에 전체 시스템의 성능과 처리량이 향상된다.

<br><br><br>

<img src="../image/kafka-1/kafka-1-9.png" width="700">

<br>

### 처리량 증대(확장)가 쉬움

Kafka는 분산 시스템으로 설계되어 있어서 클러스터에 브로커를 추가하는 것만으로도 처리량을 쉽게 증가시킬 수 있다.

<br>

### 브로커와 파티션의 확장성

하나의 브로커에서 처리할 수 있는 데이터나 처리량에 한계가 올 때, 클러스터에 브로커를 추가하여 이 한계를 극복할 수 있다. 토픽의 파티션 수를 늘려서 데이터의 쓰기와 읽기 성능을 향상시킬 수 있다.

<br>

### 컨슈머의 확장성

Kafka의 컨슈머는 컨슈머 그룹 내에서 동시에 여러 파티션의 데이터를 처리할 수 있다. 만약 컨슈머의 처리 속도가 느려지면, 컨슈머 인스턴스를 추가하거나 필요한 경우 파티션을 추가하여 성능을 향상시킬 수 있다.

<br><br><br>

<img src="../image/kafka-1/kafka-1-10.png" width="700">

<br>

### 리플리카의 정의

리플리카는 Kafka 파티션의 복제본. 이를 통해 데이터의 내구성과 가용성을 높일 수 있다.

<br>

### 복제 수 (Replication Factor)

복제 수는 특정 파티션에 대해 생성되는 복제본의 수를 나타낸다. 예를 들어, 복제 수가 3인 경우, 각 파티션에는 총 3개의 복제본이 클러스터 내 다른 브로커에 저장된다.

<br>

### 리더와 팔로워

각 파티션 복제본 중 하나는 '리더'로 지정되며, 나머지 복제본들은 '팔로워'로 지정된다.

프로듀서와 컨슈머는 메시지를 쓰거나 읽을 때 항상 해당 파티션의 리더와만 통신한다.

팔로워는 리더로부터 데이터를 지속적으로 복제받아 동기화 상태를 유지한다.

<br>

### 장애 대응

리더가 속한 브로커에 장애가 발생하면, 해당 파티션의 팔로워 중 하나가 새로운 리더로 승격된다.

이로 인해 Kafka 클러스터는 브로커의 장애에도 서비스 중단 없이 계속 동작할 수 있다.

<br><br><br>