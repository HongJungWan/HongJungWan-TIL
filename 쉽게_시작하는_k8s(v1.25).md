# 쉽게 시작하는 k8s(v1.25)

<br>

## 1. 쿠버네티스(Kubernetes)란

* 쿠버네티스(Kubernetes)는 컨테이너화된 애플리케이션을 자동으로 배포, 확장 및 관리해 주는 오픈소스 플랫폼

<br>

<img src="../../OneDrive/사진/스크린샷/1.1/1.png" width="500">

<br><br>

<img src="../../OneDrive/사진/스크린샷/1.1/2.png" width="500">

<br><br>

### 가상화 환경과 컨테이너의 차이점

<br>

#### 가상화 환경

* 가상화 환경에서는 각각의 가상 머신(VM)이 완전한 게스트 운영체제를 로드해야 하므로, 컨테이너 환경에 비해 상대적으로 처리 속도가 느리다.

<br>

#### 컨테이너 환경

* 컨테이너 환경에서는 여러 컨테이너가 단일 호스트 운영체제를 공유하기 때문에, 각 컨테이너가 별도의 무거운 운영체제를 로드할 필요가 없다. 이로 인해 컨테이너의 시작 시간과 자원 사용 효율적.

<br><br><br>

## 2. 배포를 통한 쿠버네티스 체험

<br>

### 2-1. 배포를 통해 확인하는 파드(Pod)

<img src="../../OneDrive/사진/스크린샷/2.1/3.png" width="500">

* 마스터 노드(m-k8s)에서 워커 노드들에게 nginx 애플리케이션을 설치하도록 명령을 보내는 작업을 통해 애플리케이션 배포가 진행.

<br>

* 쿠버네티스에서 애플리케이션 배포의 기본 단위는 Pod. 
  * Pod는 쿠버네티스 클러스터 내에서 스케줄링 및 관리되는 가장 작은 단위로, 하나 이상의 컨테이너를 포함할 수 있다.

<br><br>

<img src="../../OneDrive/사진/스크린샷/2.1/4.png" width="500">

* 파드는 일반적으로 관련 있는 기능을 가진 하나 이상의 컨테이너들이 결합된 쿠버네티스의 작업 단위. 
* 이 컨테이너들은 동일한 네트워크 및 리소스 네임스페이스를 공유하며, 노드의 파일 시스템을 공유할 수 있는 볼륨을 사용할 수 있다.

<br>

* 대부분의 파드는 단일 컨테이너로 이루어지지만, 복잡한 애플리케이션은 종종 여러 개의 연관된 컨테이너로 이루어진 멀티 컨테이너 파드를 사용하기도 한다.

<br>

* 볼륨은 파드 내에서 실행되는 컨테이너들이 데이터를 저장하고 공유하는 데 사용되는 일종의 디스크 공간. 이는 파드의 생명주기와 독립적으로 존재하므로, 컨테이너가 재시작되어도 데이터가 유지된다. 이렇게 함으로써 특정 컨테이너가 실패하고 재시작될 때 데이터 유실을 방지할 수 있다.

<br><br>

```text
kubectl run nginx --image=nginx
kubectl get pod
```

<br><br>

### 2-2. 파드를 외부에서도 접속하게 하는 서비스(Service)

<img src="../../OneDrive/사진/스크린샷/2.2/5.png" width="500">

* 파드는 기본적으로 클러스터 내부에서만 접근 가능. 이는 쿠버네티스의 네트워크 보안 모델에 따라 파드가 격리된 실행 환경을 가지기 때문이다.

<br>

* `ping`과 `curl` 같은 명령어를 사용해도 외부에서는 직접적으로 파드에 접근할 수 없다. 이를 해결하기 위해 쿠버네티스는 `서비스`라는 개념을 도입.

<br><br>

<img src="../../OneDrive/사진/스크린샷/2.2/7.png" width="500">

* 쿠버네티스의 서비스는 파드의 집합에 대한 액세스를 제공하는 추상화된 개념. 
* 서비스는 클러스터 내에서 실행 중인 파드를 추적하고, 파드의 변경 사항을 자동으로 감지하여 트래픽을 올바르게 라우팅한다.

<br>

* NodePort는 클러스터의 각 노드의 지정된 포트를 통해 서비스에 접근할 수 있게 해주는 서비스 타입이다. 이를 통해 외부 클라이언트가 노드의 IP 주소와 지정된 포트를 통해 서비스를 사용할 수 있다.

<br>

* 그러나 NodePort는 일반적으로 파드에 직접 연결하는 구조가 아니라, 로드 밸런싱 역할을 하며 파드에 트래픽을 전달한다. 이렇게 함으로써 여러 파드가 동일한 서비스를 제공하고 있을 때, 트래픽을 균등하게 분산할 수 있다.

<br><br>

<img src="../../OneDrive/사진/스크린샷/2.2/8.png" width="500">

<br><br>

```text
kubectl expose pod nginx --type=NodePort --port=80
kubectl get services
```

<br><br>

### 2-3. 파드와 디플로이먼트(Deployment) 차이

* 단일 파드는 유지 관리와 확장성 측면에서 한계를 가지고 있다. <br> 파드가 어떤 이유로 죽게 되면, 쿠버네티스 시스템은 자동으로 새 파드를 생성하지 않는다. <br> 이 문제를 해결하기 위해 '디플로이먼트'라는 개념이 도입되었다.

<br>

<img src="../../OneDrive/사진/스크린샷/2.3/13.png" width="500">

* 디플로이먼트는 파드의 집합을 관리하고, 파드의 생명주기를 관리하는 쿠버네티스 오브젝트다. <br> 디플로이먼트를 통해 파드의 스케일링 및 업데이트를 관리하고, 파드의 복제본 수를 유지하여 애플리케이션의 가용성을 보장할 수 있다.

<br><br>

<img src="../../OneDrive/사진/스크린샷/2.3/15.png" width="700">

* `kubectl run`, `kubectl create`, `kubectl apply`는 쿠버네티스의 CLI 도구인 `kubectl`을 사용해 파드와 디플로이먼트를 관리하는 명령어.

<br>

* `kubectl apply`는 구성 파일을 사용해 쿠버네티스 리소스를 생성하거나 업데이트하는 데 사용되는 선언적 명령어. <br> 이는 파드뿐만 아니라 디플로이먼트, 서비스 등 다양한 쿠버네티스 리소스를 관리하는 데 사용할 수 있다.

<br><br>

<img src="../../OneDrive/사진/스크린샷/2.3/16.png" width="700">

* 디플로이먼트는 `ReplicaSet`을 사용하여 파드의 복제본을 관리. <br> `ReplicaSet`은 디플로이먼트에 의해 관리되며, <br> 디플로이먼트의 주요 목표 중 하나는 이 ReplicaSet을 통해 파드의 수를 원하는 상태로 유지하는 것.

<br>

* 만약 파드의 수가 지정된 복제본 수보다 적어지면, ReplicaSet은 자동으로 새 파드를 생성하여 수를 채워넣는다. <br> 이를 통해 어플리케이션이 지속적으로 실행되도록 보장한다.

<br><br>

```text
kubectl create deployment deploy-nginx --image=nginx
kubectl get pod

kubectl scale deployment deploy-nginx --replicas=3
kubectl get pod
```

<br><br>

### 2-4. 외부로 노출하는 더 좋은 방법인 로드밸런서(LoadBalancer)

* 쿠버네티스에서는 파드를 외부에 노출하기 위한 다양한 서비스 타입을 제공. <br> 그중 `NodePort`는 각 노드의 특정 포트를 통해 서비스를 노출시킨다. 하지만 이 방식은 모든 노드의 IP를 외부에 노출시키는 문제가 있어, 보안 상의 이유로 사용이 권장되지 않는다.

<br>

* 이에 비해 'LoadBalancer'는 외부 로드밸런서를 사용하여 서비스를 노출시키는 타입이다. <br> 로드밸런서를 사용하여 트래픽을 쿠버네티스 서비스로 분산시킵니다. <br> 이 방식은 특정 노드의 IP를 직접 노출시키지 않기 때문에 보안성이 더욱 향상된다.

<img src="../../OneDrive/사진/스크린샷/2.4/20.png" width="500">

<br><br>

<img src="../../OneDrive/사진/스크린샷/2.4/23.png" width="500">

<br><br>

```text
# nginx 이름의 pod를 NodePort 타입의 서비스로 노출. 이렇게 하면 클러스터 외부에서 pod에 접근할 수 있다.
kubectl expose deployment deploy-nginx --type=NodePort --port=80
    
# 현재 설정된 모든 서비스를 조회.
kubectl get services

# Kubernetes 클러스터에 metallb.yaml 설정 파일을 적용. 이 설정 파일에는 MetalLB 로드밸런서의 설정이 포함되어 있다.
kubectl apply -f ~/_Lecture_k8s_starter.kit/ch2/2.4/metallb.yaml

# 'chk-hn'이라는 이름의 deployment를 생성. 이 deployment는 'sysnet4admin/chk-hn' 이미지를 기반으로 pod를 생성.
kubectl create deployment chk-hn --image=sysnet4admin/chk-hn
    
# 'chk-hn' deployment의 pod 수를 3개로 조정.
kubectl scale deployment chk-hn --replicas=3
    
# 현재 실행중인 모든 pod의 정보를 조회.
kubectl get pods -o wide

# 'chk-hn' deployment를 LoadBalancer 타입의 서비스로 노출, 이렇게 하면 클러스터 외부에서 이 deployment의 pod에 접근할 수 있다.
kubectl expose deployment chk-hn --type=LoadBalancer --port=80
    
# 현재 설정된 모든 서비스를 조회
kubectl get services
```

<br><br>

### 2-5. 배포한 것들 삭제하기

```text
kubectl delete service chk-hn
kubectl delete service deploy-nginx
kubectl delete service nginx

kubectl delete deployment chk-hn
kubectl delete deployment deploy-nginx
kubectl delete pod nginx

kubectl delete -f ~/_Lecture_k8s_starter.kit/ch2/2.4/metallb.yaml
```

<br>

<br><br><br>

## 3. 쿠버네티스 인사이드

<br>

### 3-1. 쿠버네티스 구성 요소 확인(+EKS, AKS, GKE 관리형 쿠버네티스)

<img src="../../OneDrive/사진/스크린샷/3.1/28.png" width="500">

<br><br>

#### 구역을 나누는 네임스페이스

<img src="../../OneDrive/사진/스크린샷/3.1/29.png" width="500">

* 네임스페이스는 쿠버네티스 클러스터 내에서 `가상 클러스터`를 생성하는 데 사용되는 메커니즘이다. <br> 네임스페이스는 독립적인 공간을 제공하여, 각 공간에서의 리소스 사용량을 관리하거나 이름 충돌을 방지하게 한다.

<br>

* `default` 네임스페이스는 쿠버네티스에서 기본적으로 제공하는 네임스페이스로, <br> 특별히 지정하지 않은 경우 모든 쿠버네티스 오브젝트는 이 네임스페이스에서 배포된다.

<br>

* `kube-system` 네임스페이스는 쿠버네티스 시스템에서 필요로 하는 오브젝트를 배치하는 곳이다. <br> 이 네임스페이스에서는 쿠버네티스 `시스템 컴포넌트`, `리소스 관리자` 등 핵심적인 오브젝트들이 동작한다.

<br><br>

### 3-2. 쿠버네티스의 기본 철학

<img src="../../OneDrive/사진/스크린샷/3.2/30.png" width="500">

<br><br>

<img src="../../OneDrive/사진/스크린샷/3.2/31.png" width="750">

<br>

### 쿠버네티스 파드 생성 및 관리 프로세스

| 용어  | 개념                                                                                                                        |
|-----|---------------------------------------------------------------------------------------------------------------------------|
|**파드 생성 요청**| API 서버에게 파드 생성 요청                                                                                                         |
|**파드 생성 감시**| 요청을 받은 API 서버는 컨트롤러 매니저에게 파드가 생성되는 것을 감시하도록 지시. <br> 컨트롤러 매니저는 상태를 지속적으로 체크하여 파드의 생성 상태를 확인.                              |
|**파드 생성**| 컨트롤러 매니저는 요청에 따라 파드를 생성하고, 생성된 파드의 상태 정보를 API 서버에 업데이트 한다. <br> 이 정보는 ReplicaSet 등의 오브젝트들이 참조할 수 있다.                      |
|**파드 스케줄링 감시**| API 서버는 쿠버네티스 스케줄러에게 새로 생성된 파드가 워커 노드에 제대로 배치되었는지 감시하도록 요청.                                                               |
|**파드 스케줄링**| 스케줄러는 API 서버로부터 파드의 정보를 받아, 이 파드를 실행할 적합한 워커 노드를 선정. <br> 스케줄러는 노드의 리소스 사용량, 노드에 걸려있는 제약 조건, 파드의 요구사항 등을 고려하여 적절한 노드를 선정. |
|**파드 배치 감시**| API 서버는 kubelet을 통해 선택된 워커 노드에 파드가 제대로 배치되었는지를 감시.                                                                        |
|**파드 동작 관리**| kubelet은 워커 노드에서 동작하며, 파드의 생성 및 관리를 담당. <br> kubelet은 컨테이너 런타임(예: Docker, containerd)에게 실제 컨테이너의 생성을 명령.                  |
|**컨테이너 생성**| 컨테이너 런타임은 kubelet의 요청에 따라 실제 컨테이너를 생성.                                                                                    |
|**파드 상태 정보 전달**| kubelet은 컨테이너가 정상적으로 생성되었음을 확인한 후, 이 정보를 API 서버에게 전달. <br> API 서버는 이 정보를 받아 파드 상태를 업데이트                                   |
|**파드 사용 가능 상태 알림**| API 서버는 최종적으로 사용자에게 파드가 사용 가능한 상태에 들어갔음을 알린다.                                                                             |

<br><br>

### 쿠버네티스의 선언적인 시스템

쿠버네티스는 선언적인 시스템으로 설계되었다. 이는 사용자가 원하는 상태를 선언하면, 쿠버네티스가 그 상태를 달성하기 위해 필요한 작업을 자동으로 수행한다는 의미다.

<br>

#### `추구하는 상태`

* 이는 사용자가 API 서버에 kubectl로 선언한 상태. 예를 들어, 특정 파드를 3개 유지하고 싶다고 선언하면, 이는 쿠버네티스의 추구하는 상태가 된다.

#### `현재 상태`

* 이는 현재 시스템의 상태를 의미한다. 위의 예에서 현재 상태가 파드가 2개라면, 쿠버네티스는 추구하는 상태와 맞추기 위해 새로운 파드를 하나 더 생성하게 된다.

<br>

쿠버네티스는 이 두 상태를 계속해서 비교하며, `현재 상태`를 `추구하는 상태`와 일치시킨다.

<br><br>

### API 서버와 ETCD

쿠버네티스의 API 서버와 etcd는 클러스터 상태의 중앙 저장소의 역할을 한다.

<br>

#### `클러스터의 업데이트된 정보 기록`

* API 서버는 사용자의 요청을 받아 이를 etcd에 저장한다. etcd는 분산 키-값 저장소로, 쿠버네티스 클러스터의 모든 상태 정보를 저장한다.

#### `API 서버에 업데이트되었음을 알림`

* etcd는 API 서버에게 상태 정보가 변경되었음을 알린다. 이 정보는 API 서버가 쿠버네티스 클러스터의 상태를 관리하는 데 사용된다.

<br><br>

### 쿠버네티스의 핵심 원칙

`쿠버네티스는 선언적인 구조다`: 쿠버네티스는 사용자가 원하는 상태를 선언하고, 쿠버네티스가 이 상태를 유지하도록 동작하는 구조.

<br>

`각 구성요소는 자기 일만 한다`: 쿠버네티스의 각 컴포넌트는 자신의 역할에 충실하며, 특정 상태를 유지하기 위한 역할을 수행. 예를 들어, 스케줄러는 파드가 워커 노드에 잘 할당되어 있는지를 확인하고, 필요한 경우 새로운 파드를 스케줄링합니다.

<br>

`쿠버네티스는 현재 상태를 추적하고, 추구하는 상태와 현재 상태를 계속 맞추려고 한다`: 쿠버네티스는 현재 클러스터의 상태를 지속적으로 감시하며, 이 상태를 사용자가 선언한 상태와 일치시킨다.

<br><br>

### 3-3. 실제 쿠버네티스의 파드 배포 흐름

<img src="../../OneDrive/사진/스크린샷/3.3/34.png" width="800">


| 용어                   | 개념                                                                                                                                   |
|----------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| 1. 명령 전달             | 관리자나 개발자는 kubectl 명령어를 통해 API 서버에 파드 생성 명령을 내린다.                                                                                     |
| 2. 정보 업데이트           | API 서버는 받은 명령 정보를 etcd에 업데이트. <br> etcd는 쿠버네티스 클러스터의 모든 상태 정보를 저장하는 분산 키-값 저장소.                                                      |
| 3. 컨트롤러 매니저의 상태 갱신   | 컨트롤러 매니저는 API 서버의 값을 확인하고, 필요한 조치를 취한 후 자신의 상태를 바꾸고 API 서버에 알린다. <br> 이를 통해 원하는 상태와 현재 상태를 동기화.                                      |
| 4. 스케줄러의 역할          | 스케줄러는 파드를 워커 노드에 할당하고 로드 밸런싱을 수행. <br> 로드 밸런싱이란, 파드를 각 워커 노드에 균등하게 분배하여, 노드 간의 부하를 균등하게 유지하는 것을 의미. <br> 스케줄러는 API 서버와 통신하여 상태 값을 업데이트. |
| 5. 파드 생성             | kubelet은 API 서버의 정보를 확인하고, 컨테이너 런타임에게 파드 생성을 명령.                                                                                     |
| 6. 컨테이너 런타임의 동작      | 컨테이너 런타임은 kubelet의 명령에 따라 실제로 파드를 생성.                                                                                                |
| 7. kube-proxy를 통한 통신 | 생성된 파드는 kube-proxy를 통해 사용자와 통신. <br> kube-proxy는 쿠버네티스 클러스터 내의 네트워킹을 관리한다.                                                           |
| 8. API 서버의 중요성       | 이 모든 통신 과정에서 API 서버가 핵심적인 역할을 수행. <br> API 서버는 쿠버네티스 클러스터 내의 모든 정보를 관리하고, 컴포넌트 간의 통신을 조정.                                            |
| 9. CoreDNS           | CoreDNS는 클러스터 내에서 DNS 서비스를 제공. <br> 이를 통해 IP 주소 대신에 도메인 이름을 사용하여 서비스에 접근할 수 있다.                 |

<br>

<br><br><br>

## 5. 쿠버네티스 오브젝트

<br><br>

### 5-1. 쿠버네티스에서 오브젝트란

<img src="../../OneDrive/사진/스크린샷/5.1/43.png" width="700">

<br><br>

### 오브젝트는 추구하는 상태를 기술해 둔 것

<img src="../../OneDrive/사진/스크린샷/5.1/45.png" width="700">

* 추구하는 상태를 기술하는 것 == 오브젝트

<br><br>

```text
kubectl edit deployment del-deploy
#vi replicas change form 9 to 3
```

<br><br>

### 5-2. 쿠버네티스 기본 오브젝트

#### 쿠버네티스는 4개의 기본 오브젝트가 존재

<br>

### 파드
<img src="../../OneDrive/사진/스크린샷/5.2/46.png" width="500">

<br><br>

### 서비스
<img src="../../OneDrive/사진/스크린샷/5.2/47.png" width="500">

<br><br>

### 네임스페이스
<img src="../../OneDrive/사진/스크린샷/5.2/48.png" width="500">

<br><br>

### 볼륨
<img src="../../OneDrive/사진/스크린샷/5.2/49.png" width="500">

* 영속적인 데이터를 보존하기 위해 만들어짐


* 파드는 언제든지 삭제, 생성이 될 수 있다. 즉, 데이터를 올리거나 지우거나 또는 데이터를 추가한다고 했을 때, 파드가 여러 군데에 돌아다니면 저장이 어려움. 볼륨을 이를 위한 저장 공간이라고 생각하면 된다.

<br><br>

```text
kubectl delete deployment del-deploy

~/_Lecture_k8s_starter.kit/ch5/5.2/nfs-exporter.sh log
cat /etc/exports

cat ~/_Lecture_k8s_starter.kit/ch5/5.2/dpy-chk-log.yaml
kubectl apply -f ~/_Lecture_k8s_starter.kit/ch5/5.2/dpy-chk-log.yaml

kubectl get pods -o wide
curl <IP>

kubectl exec dpy-chk-log-<ReplicaSet>-<HASH> -it -- /bin/bash
kubectl delete pod dpy-chk-log-<ReplicaSet>-<HASH>
kubectl exec dpy-chk-log-<ReplicaSet>-<HASH> -it -- /bin/bash
```

<br><br><br>